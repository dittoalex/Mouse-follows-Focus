#!/usr/bin/env bash
# ~/.local/bin/focus-dir
# Usage: focus-dir right|left|up|down
# GNOME (Xorg) directional focus + mouse-center without relying on extension hotkeys.
# Requires: wmctrl, xdotool, xwininfo, xprop

set -euo pipefail

dir="${1:-}"
[[ "$dir" =~ ^(right|left|up|down)$ ]] || { echo "need right|left|up|down"; exit 2; }

# ---- helpers ---------------------------------------------------------------

center_pointer_on_active() {
  local wid
  wid=$(xdotool getactivewindow) || return 0
  eval "$(xdotool getwindowgeometry --shell "$wid" 2>/dev/null)" || return 0
  xdotool mousemove --sync -w "$wid" $((WIDTH/2)) $((HEIGHT/2))
}

# integer overlap length of two 1D segments [a1,a2] and [b1,b2]
overlap_len() {
  local a1="$1" a2="$2" b1="$3" b2="$4"
  local start end len
  start=$(( a1 > b1 ? a1 : b1 ))
  end=$(( a2 < b2 ? a2 : b2 ))
  len=$(( end - start ))
  (( len < 0 )) && len=0
  echo "$len"
}

# Only consider windows that are visible (mapped) and not minimized/hidden.
is_viewable() {
  local wid_hex="$1"

  # Fast fail if xwininfo can’t see it
  xwininfo -id "$wid_hex" >/dev/null 2>&1 || return 1

  # Must be mapped/viewable
  xwininfo -id "$wid_hex" 2>/dev/null | grep -q 'Map State: IsViewable' || return 1

  # Exclude minimized/hidden
  # - WM_STATE=Iconic indicates minimized
  # - _NET_WM_STATE_HIDDEN indicates hidden (e.g. minimized)
  local props
  props=$(xprop -id "$wid_hex" WM_STATE _NET_WM_STATE 2>/dev/null || true)
  echo "$props" | grep -q 'Iconic' && return 1
  echo "$props" | grep -q '_NET_WM_STATE_HIDDEN' && return 1

  return 0
}

# ---- active window + workspace --------------------------------------------

# ---- active window + workspace --------------------------------------------

active_dec=$(xdotool getactivewindow) || exit 0
active_hex=$(printf '0x%08x' "$active_dec")

# Get active geom from wmctrl (same source as candidates) for consistency
# wmctrl -lG: HEX_ID DESK X Y W H HOST TITLE...
read -r _ah_id desk ax ay aw ah _rest < <(wmctrl -lG | awk -v id="$active_hex" '$1==id {print $0}')
# Fallback if wmctrl didn’t find it (e.g., transient window)
if [[ -z "$ax" ]]; then
  eval "$(xdotool getwindowgeometry --shell "$active_dec" 2>/dev/null)" || exit 0
  ax=$X; ay=$Y; aw=$WIDTH; ah=$HEIGHT
  # Desk via xprop
  desk=$(xprop -id "$active_dec" _NET_WM_DESKTOP | awk '{print $3}')
fi

# ---- find best candidate in the requested direction -----------------------

best_hex=""
best_score=9223372036854775807  # "infinity"
min_overlap_frac=35              # require >=25% overlap on perpendicular axis
slop=8                           # a tiny pixel slop to ignore borders/gaps

# wmctrl -lG -> HEX_ID DESK X Y W H HOST TITLE...
while read -r wid_hex d wx wy ww wh _rest; do
  # Stay on the same workspace; allow sticky (-1)
  [[ "$d" == "$desk" || "$d" == "-1" ]] || continue

  # Skip self (compare in hex to avoid conversion pitfalls)
  [[ "$wid_hex" == "$active_hex" ]] && continue

  # Only consider viewable (visible, not minimized/hidden) windows
  is_viewable "$wid_hex" || continue

  # Edges
    # centers and edges (we already have ax, ay, aw, ah, etc.)
  wcx=$((wx + ww/2))
  wcy=$((wy + wh/2))
  acx=$((ax + aw/2))
  acy=$((ay + ah/2))

  local_left=$wx
  local_right=$((wx + ww))
  local_top=$wy
  local_bottom=$((wy + wh))

  active_right=$((ax + aw))
  active_bottom=$((ay + ah))

  # Tunables
  min_overlap_frac_x=10   # softer requirement for vertical moves
  slop=2                  # border forgiveness
  cone_ratio=2            # allow |dx| <= cone_ratio * |dy| for up/down

  case "$dir" in
    right)
      (( local_left < active_right - slop )) && continue
      ov=$(overlap_len "$ay" "$active_bottom" "$wy" "$local_bottom")
      min_needed=$(( (ah < wh ? ah : wh) * min_overlap_frac / 100 ))  # keep your 25% here
      (( ov < min_needed )) && continue
      score=$(( local_left - active_right ))                          # edge distance
      ;;
    left)
      (( local_right > ax + slop )) && continue
      ov=$(overlap_len "$ay" "$active_bottom" "$wy" "$local_bottom")
      min_needed=$(( (ah < wh ? ah : wh) * min_overlap_frac / 100 ))  # keep your 25% here
      (( ov < min_needed )) && continue
      score=$(( ax - local_right ))                                   # edge distance
      ;;
    down)
      # primarily by center-Y with a "vertical cone" OR small horizontal overlap
      dy=$(( wcy - acy ))
      (( dy <= slop )) && continue
      dx_abs=$(( wcx > acx ? wcx - acx : acx - wcx ))

      ov=$(overlap_len "$ax" "$active_right" "$wx" "$local_right")
      min_needed=$(( (aw < ww ? aw : ww) * min_overlap_frac_x / 100 ))  # 10% by default

      cone_ok=false
      (( dx_abs <= cone_ratio * dy )) && cone_ok=true

      if ! $cone_ok && (( ov < min_needed )); then
        continue
      fi

      # Prefer nearer vertical targets; break ties by being more centered
      score=$(( dy * 1000 + dx_abs ))
      ;;
    up)
      dy=$(( acy - wcy ))
      (( dy <= slop )) && continue
      dx_abs=$(( wcx > acx ? wcx - acx : acx - wcx ))

      ov=$(overlap_len "$ax" "$active_right" "$wx" "$local_right")
      min_needed=$(( (aw < ww ? aw : ww) * min_overlap_frac_x / 100 ))  # 10%

      cone_ok=false
      (( dx_abs <= cone_ratio * dy )) && cone_ok=true

      if ! $cone_ok && (( ov < min_needed )); then
        continue
      fi

      score=$(( dy * 1000 + dx_abs ))
      ;;
  esac

  (( score < best_score )) && { best_score=$score; best_hex="$wid_hex"; }
done < <(wmctrl -lG)


# ---- focus + center --------------------------------------------------------

if [[ -n "$best_hex" ]]; then
  wmctrl -ia "$best_hex"
  sleep 0.03
  center_pointer_on_active
else
  center_pointer_on_active
fi
